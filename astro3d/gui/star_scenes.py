"""This module contains several subclasses of ``QGraphicsScene``.
These are instantiated by `~astro3d.gui.astroVisual.MainPanel` and
are used to display the image and any regions.
Furthermore, `RegionStarScene` and `ClusterStarScene` allow
user input upon mouse click.

"""
from __future__ import division, print_function

# STDLIB
from collections import defaultdict

# Anaconda
from astropy.table import Table
from PyQt4.QtGui import *
from PyQt4.QtCore import *


class StarScene(QGraphicsScene):
    """This is a non-interactive subclass of ``QGraphicsScene``.
    It will display the image and any regions that have been added.

    Parameters
    ----------
    parent : `~astro3d.gui.astroVisual.MainPanel`
        The instantiating class.

    width, height : int
        The size of the `~astro3d.gui.astroVisual.MainPanel`,
        which allows `StarScene` to scale the image appropriately.

    Attributes
    ----------
    size : QSize
        Size of the `~astro3d.gui.astroVisual.MainPanel`.

    pixmap : QGraphicsPixmapItem
        Image the regions belong to.

    regions : dict
        Contains region type and a list of `~astro3d.gui.astroObjects.Region`, which provides `StarScene` with a pointer to each region, allowing them to be removed if necessary. ``Region.name`` must contain region type.

    """
    _SCENE_COLOR = QColor(0, 100, 200)
    _SELECTED_COLOR = QColor(255, 0, 0)

    def __init__(self, parent, width, height):
        super(StarScene, self).__init__(parent)
        self.size = QSize(width, height)
        self.pixmap = None
        self.regions = defaultdict(list)

    def addImg(self, pixmap):
        """Scales the input pixmap to appropriate size for the
        `~astro3d.gui.astroVisual.MainPanel`, then adds it to
        the display. Adds all regions on top of image.

        .. note::

            Returns the scaled pixmap to save so that scaling will be
            unnecessary in the future.

        Parameters
        ----------
        pixmap : QPixmap

        Returns
        -------
        scaledPixmap : QPixmap

        """
        scaledPixmap = pixmap.scaled(self.size, Qt.KeepAspectRatio)
        self.pixmap = QGraphicsPixmapItem(scaledPixmap)
        self.draw()
        return scaledPixmap

    def addReg(self, region):
        """Adds a given region to the display.

        .. note::

            The recursive behavior is for ``MergedRegion``,
            which is not currently supported.

        Parameters
        ----------
        region : `~astro3d.gui.astroObjects.Region`

        """
        if isinstance(region, (list, tuple)):
            return map(self.addReg, region)
        else:
            self.regions[region.name].append(region)
            self.draw()

    def delReg(self, region):
        """Remove a given region from the display.

        .. note::

            The recursive behavior is for ``MergedRegion``,
            which is not currently supported.

        Parameters
        ----------
        region : `~astro3d.gui.astroObjects.Region`

        """
        if isinstance(region, (list, tuple)):
            map(self.delReg, region)
        else:
            self.regions[region.name].remove(region)
            self.draw()

    def clear(self):
        """Removes all items from the display without destroying
        instance variables.

        """
        for i in self.items():
            self.removeItem(i)

    def draw(self, selected=[]):
        """Draw scene. Highlight selected region(s)."""
        if not isinstance(selected, list):
            selected = [selected]

        self.clear()

        if self.pixmap is not None:
            self.addItem(self.pixmap)

        for reglist in self.regions.itervalues():
            for reg in reglist:
                r = QGraphicsPolygonItem(reg.region)
                if reg in selected:
                    r.setPen(self._SELECTED_COLOR)
                else:
                    r.setPen(self._SCENE_COLOR)
                self.addItem(r)


class RegionStarScene(QGraphicsScene):
    """This is an interactive subclass of ``QGraphicsScene``.
    Every time the user clicks on the image, it generates a point
    and adds it to a ``QPolygon``, allowing it to display that
    polygon as a region.

    Parameters
    ----------
    parent : `~astro3d.gui.astroVisual.MainPanel`
        The instantiating class.

    pixmap : QPixmap
        The scaled QPixmap generated by :meth:`StarScene.addImg`.
        It is added so that `RegionStarScene` can display the image.

    name : str
        Name (type) of the region to be drawn.

    Attributes
    ----------
    name : str
        Same as input.

    description : str
        Description of the region (informational only).

    item : QGraphicsPixmapItem
        Created from ``pixmap``.

    graphicspoints : list of `RegionStarSceneItem`
        Displayed circles representing ``points``.

    """
    _REGION_COLOR = QColor(0, 100, 200)
    _MIN_POINTS = 3

    def __init__(self, parent, pixmap, name):
        super(RegionStarScene, self).__init__(parent)
        self.name = name
        self.description = name
        self.item = QGraphicsPixmapItem(pixmap)
        self.graphicspoints = []
        self._i_to_move = None
        self.draw()

    def mousePressEvent(self, event):
        """This method is called whenever the user clicks on
        `RegionStarScene`.

        It adds a new point clicked to ``graphicspoints``.
        If the point already exists, right click will remove it.
        To move an existing point, select it with left click and
        then CNTRL+click the new position.
        If 3 or more points are present, it generates `shape` and
        draws a polygon.

        Parameters
        ----------
        event : QEvent

        """
        p = event.scenePos()
        flag, i = self.has_point(p)

        if flag:
            if event.button() == Qt.RightButton:  # Remove point
                self.graphicspoints.pop(i)
                self.reset_point_selection()
            else:  # Mark point to be moved
                self._i_to_move = i
                self.graphicspoints[self._i_to_move].do_selection()
        else:
            if event.button() == Qt.LeftButton:
                gp = RegionStarSceneItem(p)
                modifiers = QApplication.keyboardModifiers()
                if modifiers == Qt.ControlModifier:  # Move point
                    if self._i_to_move is not None:
                        self.graphicspoints[self._i_to_move] = gp
                else:  # Add point
                    self.graphicspoints.append(gp)
            self.reset_point_selection()

        self.draw()

    def reset_point_selection(self):
        """Undo any highlighted point."""
        if self._i_to_move is not None:
            self.graphicspoints[self._i_to_move].undo_selection()
            self._i_to_move = None

    def has_point(self, p):
        """Check if given point already exists.

        Parameters
        ----------
        p : QPointF

        Returns
        -------
        flag : bool
            `True` if point exists, else `False`.

        idx : int or `None`
            Corresponding index in ``self.points`` and
            ``self.graphicspoints``, if exists.

        """
        flag = False
        idx = None

        for i, gp in enumerate(self.graphicspoints):
            if gp.contains(p):
                flag = True
                idx = i
                break

        return flag, idx

    @property
    def shape(self):
        """Polygon shape."""
        if len(self.graphicspoints) < self._MIN_POINTS:
            s = None
        else:
            s = QPolygonF([gp.pos for gp in self.graphicspoints])
        return s

    def draw(self):
        """Draw points and polygon."""
        for i in self.items():
            self.removeItem(i)

        self.addItem(self.item)

        for gp in self.graphicspoints:
            self.addItem(gp)

        shape = self.shape
        if shape is not None:
            display_shape = QGraphicsPolygonItem(shape)
            display_shape.setPen(QPen(self._REGION_COLOR))
            self.addItem(display_shape)

    def getRegion(self):
        """Return information of region to save.

        Returns
        -------
        name : str
            Name (key) of the region.

        shape : QPolygonF
            Shape of the region.

        description : str
            Description of the region.

        """
        return self.name, self.shape, self.description

    def clear(self):
        """Removes all items from the display except the image.
        Resets all instance variables except for ``item``.

        """
        for i in self.items():
            self.removeItem(i)
        self.addItem(self.item)
        self.graphicspoints = []


class RegionStarSceneItem(QGraphicsEllipseItem):
    """Class to handle data points in `RegionStarScene`.

    Parameters
    ----------
    pos : QPointF
        Initial position of the data point.

    """
    _ELLIPSE_SZ = 10
    _ELLIPSE_RAD = _ELLIPSE_SZ // 2
    _ELLIPSE_COLOR = QColor(0, 255, 0)
    _SELECTED_COLOR = QColor(255, 0, 0)

    def __init__(self, pos):
        super(RegionStarSceneItem, self).__init__(
            pos.x() - self._ELLIPSE_RAD, pos.y() - self._ELLIPSE_RAD,
            self._ELLIPSE_SZ, self._ELLIPSE_SZ)
        self.pos = pos
        self.setPen(QPen(self._ELLIPSE_COLOR))
        self.setAcceptHoverEvents(True)
        self._default_brush = self.brush()
        self._highlight_brush = QBrush(self._ELLIPSE_COLOR)

    def do_selection(self):
        """Mark as selected."""
        self.setPen(QPen(self._SELECTED_COLOR))

    def undo_selection(self):
        """Undo :meth:`do_selection`."""
        self.setPen(QPen(self._ELLIPSE_COLOR))

    def hoverEnterEvent(self, event):
        """Highlight point on mouse over."""
        self.setBrush(self._highlight_brush)

    def hoverLeaveEvent(self, event):
        """Un-highlight point when mouse leaves."""
        self.setBrush(self._default_brush)


class RegionFileScene(QGraphicsScene):
    """Like `RegionStarScene` but the regions are pre-loaded from files."""
    _REGION_COLOR = QColor(0, 100, 200)

    def __init__(self, parent, pixmap, regions):
        super(RegionFileScene, self).__init__(parent)
        self.item = QGraphicsPixmapItem(pixmap)
        self.addItem(self.item)

        if isinstance(regions, list):
            self.name = []
            self.shape = []
            self.description = []

            for reg in regions:
                self.name.append(reg.name)
                self.shape.append(reg.region)
                self.description.append(reg.description)
                display_shape = QGraphicsPolygonItem(reg.region)
                display_shape.setPen(QPen(self._REGION_COLOR))
                self.addItem(display_shape)

        else:
            self.name = regions.name
            self.shape = regions.region
            self.description = regions.description
            display_shape = QGraphicsPolygonItem(self.shape)
            display_shape.setPen(QPen(self._REGION_COLOR))
            self.addItem(display_shape)

    def getRegion(self):
        """Return information of region(s) to save.

        Returns
        -------
        name : str or list
            Name (key) of the region.

        shape : QPolygonF or list
            Shape of the region.

        description : str or list
            Description of the region.

        """
        return self.name, self.shape, self.description

    def clear(self):
        """Removes all items from the display except the image."""
        for i in self.items():
            self.removeItem(i)
        self.addItem(self.item)


class ClusterStarScene(QGraphicsScene):
    """An interactive subclass of ``QGraphicsScene``.
    Displays the given stars or star clusters, using circles
    to highlight their locations.

    The user may click on existing point to remove it from
    consideration, or on unmarked area to add it.

    Parameters
    ----------
    parent : `~astro3d.gui.astroVisual.MainPanel`
        The instantiating class.

    _file : `~astro3d.gui.astroObjects.File`
        File object.

    data : `astropy.table.Table`
        Table data to add.

    key : {'clusters', 'stars'}
        Type of ``File.peaks`` table to process.

    Attributes
    ----------
    _file, key
        Same as inputs.

    scale : float
        Scaling factor to convert between display and native coordinates.

    graphicspoints : QGraphicsEllipseItems
        Points displayed on screen.

    """
    _ELLIPSE_SZ = 10
    _ELLIPSE_RAD = _ELLIPSE_SZ // 2
    _ELLIPSE_COLOR = QColor(200, 50, 50)
    _FLUX_RAD = 5

    def __init__(self, parent, _file, data=None, key='clusters'):
        super(ClusterStarScene, self).__init__(parent)
        self._file = _file
        self.key = key
        self.scale = self._file.scale()
        self.graphicspoints = []

        # Display static background image
        self.addItem(QGraphicsPixmapItem(_file.image))

        if data is None:
            data = Table(names=['xcen', 'ycen', 'flux'])
        else:
            data.keep_columns(['xcen', 'ycen', 'flux'])
            xcen = data['xcen'] * self.scale
            ycen = data['ycen'] * self.scale
            for x, y in zip(xcen, ycen):
                self.add_point(x, y)

        self._file.peaks[self.key] = data

    def add_point(self, xcen, ycen):
        """Add a point to graphics scene.

        Parameters
        ----------
        xcen, ycen : float
            Coordinate of the point in display scale.

        """
        x = xcen - self._ELLIPSE_RAD
        y = ycen - self._ELLIPSE_RAD
        item = QGraphicsEllipseItem(x, y, self._ELLIPSE_SZ, self._ELLIPSE_SZ)
        item.setPen(QPen(self._ELLIPSE_COLOR))
        self.graphicspoints.append(item)
        self.addItem(item)

    def mousePressEvent(self, event):
        """This method is called whenever the user clicks
        on the screen.

        If the click is on one of the displayed
        points, that point is removed from the screen
        and table. Otherwise, it is added.

        Parameters
        ----------
        event : QEvent

        """
        p = event.scenePos()
        is_removed = False

        for i, gp in enumerate(self.graphicspoints):
            if gp.contains(p):
                is_removed = True
                self.removeItem(gp)
                self.graphicspoints.remove(gp)
                self._file.peaks[self.key].remove_row(i)
                break

        if not is_removed:
            xdisp = p.x()
            ydisp = p.y()
            xcen = xdisp / self.scale
            ycen = ydisp / self.scale

            # Estimate flux at selected point
            ix1 = max(int(xcen - self._FLUX_RAD), 0)
            ix2 = min(int(xcen + self._FLUX_RAD), self._file.data.shape[1])
            iy1 = max(int(ycen - self._FLUX_RAD), 0)
            iy2 = min(int(ycen + self._FLUX_RAD), self._file.data.shape[0])
            flux = self._file.data[iy1:iy2, ix1:ix2].sum()

            self.add_point(xdisp, ydisp)
            self._file.peaks[self.key].add_row([xcen, ycen, flux])
